import json
import random
import re
import textwrap
from abc import ABC, abstractmethod
from dataclasses import asdict, dataclass
from enum import Enum
from typing import Any, Callable, Mapping, Self, Sequence

from src.agents.agent_manager import Agent
from src.utils.concurrency import run_tasks


class Action(Enum):
    """Base class for actions in the game"""

    def to_token(self) -> str:
        """Convert the action to a token (eg, A1) starting from A0 for LLM parsing."""
        idx = list(type(self)).index(self)
        return f"A{idx}"

    @classmethod
    def from_token(cls, token: str) -> Self:
        """Parse an action from a token like "A0" or "A1"."""
        try:
            idx = int(token.lstrip("A"))
            action = list(cls)[idx]
        except Exception as exp:
            raise ValueError(f"Unknown action token {token!r}") from exp
        return action

    @classmethod
    def from_index(cls, index: int) -> Self:
        """Get action from its index."""
        try:
            action = list(cls)[index]
        except Exception as exp:
            raise ValueError(f"Unknown action index {index!r}") from exp
        return action


@dataclass
class Move:
    """
    A record of one player's action in a single round.

    Attributes:
        name: The name of the player (unique)
        uid: The unique id of the player
        action: The action taken by the player.
        points: The points scored by the player in this round.
        response: The full response generated by the player.
    """

    uid: int
    player_name: str
    action: Action
    points: float
    response: str
    trace_id: str

    def to_dict(self) -> dict[str, Any]:
        """Convert the Move to a dictionary, mostly for logging and record purpose."""
        d = asdict(self)
        d["action"] = str(self.action)
        return d


class Game(ABC):
    """
    Base class for all games in the tournament.
    """

    def __init__(
        self,
        prompt: str,
        *,
        num_players: int,
        is_symmetric: bool = True,
    ) -> None:
        self.prompt = prompt
        self.num_players = num_players
        self.number_to_position = {1: "first", 2: "second", 3: "third", 4: "fourth"}
        self.is_symmetric = is_symmetric
        self.num_actions = len(self.action_cls)
        self.default_output_instruction = textwrap.dedent(
            """
        Instruction:
        - Choose a probability distribution over the provided actions each round.
        - Output must contain a valid JSON object at the end.
        - Keys must be the action names exactly as given.
        - Values must be integers between 0 and 100.
        - The values must sum to exactly 100.

        Format requirement:
        Return exactly one JSON object, for example:
        {"A0": <INT>, "A1": <INT>, ...}
        """
        )

    @property
    @abstractmethod
    def action_cls(self) -> type[Action]:
        """Get the Action class associated with this game."""

    def get_player_prompt(self, player_id: int) -> str:
        """Get game prompt from specific player's perspective. Per default, this is the same for all players in symmetric games."""
        return self.prompt + f"\nIn case player identification becomes relevant, you are playing in the position of Player {player_id} in this game.\n"

    @abstractmethod
    def play(
        self,
        additional_info: list[str] | str,
        players: Sequence[Agent],
        action_map: Callable = lambda x: x,
    ) -> list[Move]:
        """Play the game."""
        raise NotImplementedError

    def prompt_player_mix_probs(
        self,
        player: Agent,
        extra_info: str | None = None,
        output_instruction: str | None = None,
    ) -> tuple[str, str, dict[int, float]]:
        """
        Given the mechanism's additional info and the base game prompt,
        format the full prompt and query the player.

        Returns the player's raw response.
        """
        prompt = self.get_player_prompt(player.player_id)

        if extra_info:
            prompt += extra_info

        if output_instruction is None:
            output_instruction = self.default_output_instruction
        prompt += "\n" + output_instruction

        response, trace_id, mix_probs = player.chat_with_retries(
            prompt, self._parse_mixed_probs
        )
        return response, trace_id, mix_probs

    def _parse_mixed_probs(
        self,
        response: str,
    ) -> dict[int, float]:
        """
        Parse mixed strategy pairs like '<A0=60>|<A1=25>|<A2=15>'.
        Rules:
        - integers only
        - each in [0,100]
        - sum exactly 100
        """
        matches = re.findall(r"\{.*?\}", response, re.DOTALL)
        if not matches:
            raise ValueError(
                f"No JSON object found in the response {response!r}"
            )
        json_str = matches[-1]

        try:
            json_obj = json.loads(json_str)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON: {e.msg}") from e

        result = {}
        total = 0
        for k, v in json_obj.items():
            if not isinstance(v, int):
                raise ValueError(f"Value for {k} must be an integer, got {v!r}")
            if not 0 <= v <= 100:
                raise ValueError(
                    f"Value for {k} must be between 0 and 100, got {v}"
                )
            idx = int(k[1:])  # strip the leading 'A'
            result[idx] = v
            total += v

        got_keys = set(result.keys())
        missing = set(range(self.num_actions)) - got_keys
        if missing:
            raise ValueError(f"Action key mismatch. Missing: {sorted(missing)}")

        if total != 100:
            raise ValueError(f"Probabilities must sum to 100 (got {total}).")

        return result

    @staticmethod
    def _choose_from_mix_strategy(probs: dict[int, float]) -> int:
        keys = list(probs.keys())
        weights = list(probs.values())
        return random.choices(keys, weights=weights, k=1)[0]

    def _collect_actions(
        self,
        players: Sequence[Agent],
        info: Sequence[str],
        action_map: Callable = lambda x: x,
    ) -> dict[int, tuple[Action, str, str]]:
        if len(players) != len(info):
            raise ValueError(f"Count mismatch: {len(players)} vs {len(info)}.")

        def query(player: Agent, extra_info: str):
            response, trace_id, mix_probs = self.prompt_player_mix_probs(
                player, extra_info=extra_info
            )
            action_idx = self._choose_from_mix_strategy(mix_probs)
            return player.uid, action_map(action_idx), response, trace_id

        return {
            uid: (self.action_cls.from_index(action), resp, trace)
            for uid, action, resp, trace in run_tasks(
                zip(players, info), lambda p: query(*p)
            )
        }


class GridGame(Game):
    """
    A base class for grid-based games.
    """

    def __init__(
        self,
        prompt: str,
        payoff_matrix: Mapping[str, Sequence[float]],
        *,
        num_players: int,
        is_symmetric: bool = True,
    ) -> None:
        self.payoff_matrix = self._parse_payoff_matrix(payoff_matrix)
        super().__init__(
            prompt,
            num_players=num_players,
            is_symmetric=is_symmetric,
        )

    def _parse_payoff_matrix(
        self,
        raw_payoff: Mapping[str, Sequence[float]],
    ) -> dict[
        tuple[Action, Action],
        tuple[float, float],
    ]:
        """
        Convert a raw payoff matrix with string keys into typed action pairs.
        """
        payoffs = {}
        for key, (p1, p2) in raw_payoff.items():
            a1 = self.action_cls(key[0])
            a2 = self.action_cls(key[1])
            payoffs[(a1, a2)] = (p1, p2)
        return payoffs

    def _payoff_description(self) -> str:
        lines = []
        for (a, b), (pts_a, pts_b) in self.payoff_matrix.items():
            lines.append(
                f"\t- If you choose {a.to_token()} and the other player chooses {b.to_token()}: "
                f"you get {pts_a} points, the other player gets {pts_b} points."
            )
        return "\n".join(lines)
